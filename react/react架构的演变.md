# React 架构的演变

> 主要是从 React15 到 React16 由树型变成 Fiber 架构到底改变了什么。

## 从同步到异步

React15特性：

* React15 存在一些不可避免的缺陷，众说周知，React15中，setState 在正常情况下并不会立即更新，要在 setState 的回掉函数中才能拿到更新的结果，同时，在 React 生命周期内，多次 setState 会被合并为一次，页面也只做一次更新；
* 只要不脱离 React，不管多少次 setState 都会把其组件放入脏组件队列等待更新。一旦脱离 React 的管理，比如在 setTimeout 中，setState 立马变成单打独斗；
* React15总体上说，是 **同步操作** 进行的更新，并没有进入异步队列；

React16特性：
* 引入了 Fiber 架构，提供了 **异步渲染** 的能力，异步渲染指的是 Concurrent 模式，
* Concurrent 模式说白就是让 **组件更新异步化** ，切分时间片，渲染之前的调度、diff、更新都只在指定时间片进行，如果超时就暂停放到下个时间片进行，中途给浏览器一个喘息的时间。
* 在 Concurrent 模式下，即使脱离了 React 的生命周期，setState 依旧能够合并更新。主要原因是 Concurrent 模式下，真正的更新操作被移到了 **下一个事件队列** 中，类似于 Vue 的 nextTick。
* React 通过 expirationTime 来判断是否超时，如果超时就把任务放到后面来执行。所以，异步模型中 setTimeout 里面进行 setState，只要当前时间片没有结束（currentTime 小于 expirationTime），依旧可以将多个 setState 合并成一个。（一个时间片里可能执行了多个 setTimeout，那这多个 setTimeout 里的 setState 依旧可以被合并执行），所以整个更新架构相比较 React15 完全不同了；


## 从递归到循环

React16 的 Fiber 框架下通过 **链表循环** 遍历更新，之所以要使用循环遍历的方式，是因为递归更新过程一旦开始就不能暂停，只能不断向下，直到递归结束或者出现异常；

React15 树型递归更新：

* 首先获取需要更新的脏组件数组，然后逐一取出组件进行递归，不停的向下寻找子节点来查找是否需要更新，直到递归完所有组件，表示更新完成；所以缺点也很明显，不能暂停更新，一旦更新必须冲头到尾；
* 这也是因为虚拟 dom 在每个 dom 节点上只只保留了其 child 组件信息，如果递归中断，无法保留现场；

React15 更新机制：
* 待更新列表为数组结构；
* 而且整个更新过程都是阻塞的，也就是必须要等待当下更新全部完成，这就导致了 js 的执行可能阻塞渲染的进行，导致页面出现卡顿；


React16 链表循环更新：

* Fiber 为链表结构，每个 Fiber 节点增加了父亲与兄弟节点的信息，这意味着，可以通过遍历树的方式循环遍历，只要记住当前遍历位置，中断后也能快速恢复现场，继续完成后续遍历；

React16 更新机制；

* Fiber 上多个 setState 产生的变化为链表结构；
* 获取到需要更新的组件并不是必须一次更新完成，React16 实现了自己的一套拆分时间片的方式，每个时间片并不会完全用来执行 js，未执行完的更新会放到下一个时间片里，给浏览器“喘口气”的时间，在这个“喘口气”的时间里，浏览器可以进行新的渲染，这么做让渲染变得更加流畅，不容易出现卡帧的现象；

