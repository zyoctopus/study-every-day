

## 网络篇

1. 浏览器构建请求；
2. 查找强缓存，如果强缓存命中，直接使用，否则进行网络请求；
3. 通过DNS解析，查找目标服务器ip；
> 注意：浏览器提供DNS缓存服务，如果当前域名解析过，那再次访问就不需要通过DNS解析，直接缓存获取；http不指定端口默认走80端口，https默认走443端口；
4. 建立TCP连接，Chrome默认情况下同一个域名下可同时建立六个TCP连接，多出的请求需要等待；
> TCP协议，属于传输层协议，通过三次握手建立客户端与服务器之间的连接；然后进行数据传输，传输过程中，接收方需要向发送发确认，如果没有确认，发送发就认定丢包，重新发送；数据传输完成，通过四次挥手来断开连接；

> TCP 连接通过什么手段来保证数据传输的可靠性，一是`三次握手`确认连接，二是`数据包校验`保证数据到达接收方，三是通过`四次挥手`断开连接。

> http三次握手是为了，确认双方的接收与发送能力是否正常；只有通过三次握手，才能确认四个事情，发送方的接受和发送能力，接收方的接受和发送能力，少一次就无法确认全部事情，所以才一定要发三次握手；

> 第三次握手的时候可以携带数据，前两次不可以；

> 四次挥手，因为需要双方确认没有要发送的内容，服务器收到客户端报文要关闭连接，第一次只做**收到关闭的应到**，并不会立即关闭，服务器确认没有需要发送的内容后，再发送FIN报文，进入LAST_ACK 的状态，等待关闭；客户端发送最后一次报文后并不会立刻关闭连接，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。
5. 发送HTTP请求，包括请求行，请求头，请求体（POST才有）
6. 网络响应，服务器把请求数据返回给浏览器，网络响应也包括，响应行，响应头，响应体；

## 解析算法篇

> 完成了网络请求和响应部分之后就进入到浏览器解析渲染部分了；

1. 构建dom树，将通过服务端响应获得的HTML翻译成 `DOM树`；
2. 样式计算，渲染引擎接收到 CSS 文本之后第一件事情就是将其转化为一个结构化的对象，即styleSheets；css样式中有趣的两部分，继承和层叠；
3. 生成 `布局树`，通过dom树和样式生成Layout Tree（布局树）；

> 有人说首先会生成 `Render Tree`，也就是渲染树，然后再生成`Layout Tree` ，其实这还是 16 年之前的事情，现在 Chrome 团队已经做了大量的重构，已经没有生成 `Render Tree` 的过程了。而布局树的信息已经非常完善，完全拥有 `Render Tree` 的功能。
 
## 渲染过程篇

> 经过上面的阶段，接下来就是渲染了；

1. 建立图层树，布局树上，可以理解为是平面位置信息，图层树解决了动画及层叠的显示效果等；
2. 生成绘制列表；
3. 生成图块和生成位图；现在开始绘制操作，实际上在渲染进程中绘制操作是由专门的线程来完成的，这个线程叫**合成线程**。
4. 显示器显示；


## 重排和重绘

* 重排：对 DOM 的结构修改导致DOM的几何尺寸的变化；将解析合成的流程全部走一遍，开销是非常大的；
* 重绘：当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候；
* 重绘不一定导致重排，但重排一定发生了重绘；