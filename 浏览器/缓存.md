## 强缓存

1. `http/1.0` 的时候用的 **Expires**，缓存时间为具体的时间点，例如：

```
Expires: Wed, 22 Nov 2019 08:41:00 GMT
```

> 缺点：服务器时间和浏览器 `时间可能不一致`，那过期时间就是不准确的，所以在 `http/1.1中被废除` 了。

2. `http/1.1` 中更多使用 **Cache-Control**，不以具体时间点为过期日期，而是采用过期时长为来控制缓存；存在以下字段：

    * max-age：过期时长；
    * public： 客户端和代理服务器都可以缓存；
    * private： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存；
    * no-cache： 跳过当前的强缓存，发送HTTP请求，即直接进入`协商缓存阶段`；
    * no-store：不进行任何形式的缓存；
    * s-maxage：代理服务器的缓存时长；

 注意：当**Expires**和**Cache-Control**同时存在的时候，**Cache-Control**会优先考虑。也就是Cache-Control的优先级高于Expires；

## 协商缓存

> 强缓存失效后，会进入协商缓存，浏览器在请求头中携带相应的  `缓存tag` 来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是**协商缓存**

1. **Last-Modified**：即最后修改时间。
    * 在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段；
    * 浏览器接收到后，如果再次请求，会在请求头中携带 `If-Modified-Since` 字段，这个字段的值也就是服务器传来的最后修改时间；
    * 服务器拿到请求头中的 `If-Modified-Since` 的字段后，其实会和这个服务器中`该资源的最后修改时间`对比；
    * 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样；
    * 否则 `返回304`，告诉浏览器直接用缓存。

2. **Etag**
    * 服务器根据当前文件的内容，给文件生成的唯一标识，服务器通过`响应头`把这个值给浏览器；
    * 浏览器接收到 `ETag` 的值，会在下次请求时，将这个值作为 `If-None-Match` 这个字段的内容，并放到请求头中，然后发给服务器。
    * 服务器接收到 `If-None-Match` 后，会跟服务器上该资源的 `ETag` 进行比对:
    * 如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
    * 否则返回304，告诉浏览器直接用缓存。


协商缓存两种方式对比：

1. `Etag`的准确性优于 `Last-Modified`，在一些特殊情况下`Last-Modified` 并不能准确感知变化；
    * 编辑了资源文件，但是文件没有更改，`Last-Modified` 就将失效；
    * `Last-Modified` 能感知的时间单位是秒，如果在一秒内修改多次，这时候Last-Modified也无法体现；

2. Last-Modifed在性能上优于Etag，1.  也很简单理解，`Last-Modified` 仅仅只是记录一个时间点，而 `Etag` 需要根据文件的具体内容生成哈希值。


##  缓存存放的的位置

浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：

*   Service Worker：离线缓存，Service Worker Cache，PWA的重要实现机制
*   Memory Cache：内存缓存，读取速度比磁盘缓存快，存活时间短
*   Disk Cache：磁盘缓存，存活时间久

    既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：

    *   比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存
    *   内存使用率比较高的时候，文件优先进入磁盘

*   Push Cache：推送缓存，这是浏览器缓存的最后一道防线。它是 `HTTP/2` 中的内容


